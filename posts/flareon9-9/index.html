<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Flare-On 9: 09_encryptor | Gar Reversing</title>
<meta name=keywords content="flareon,writeup">
<meta name=description content="Flare-On is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.">
<meta name=author content="Gary">
<link rel=canonical href=https://gar-re.github.io/posts/flareon9-9/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.319f7209271a6127ecb9f000084aa4ce7f5f4394f5ef702b9cbb0f5bdd4523de.css integrity="sha256-MZ9yCScaYSfsufAACEqkzn9fQ5T173ArnLsPW91FI94=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gar-re.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://gar-re.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://gar-re.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://gar-re.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://gar-re.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript><meta property="og:title" content="Flare-On 9: 09_encryptor">
<meta property="og:description" content="Flare-On is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gar-re.github.io/posts/flareon9-9/">
<meta property="og:image" content="https://gar-re.github.io/posts/flareon9-9/cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-11-12T00:00:00+00:00">
<meta property="article:modified_time" content="2022-11-12T00:00:00+00:00"><meta property="og:site_name" content="Gar Reversing">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://gar-re.github.io/posts/flareon9-9/twittercard.png">
<meta name=twitter:title content="Flare-On 9: 09_encryptor">
<meta name=twitter:description content="Flare-On is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gar-re.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Flare-On 9: 09_encryptor","item":"https://gar-re.github.io/posts/flareon9-9/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flare-On 9: 09_encryptor","name":"Flare-On 9: 09_encryptor","description":"Flare-On is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.\n","keywords":["flareon","writeup"],"articleBody":"Flare-On is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.\nThis year‚Äôs contest included 11 challenges ranging from Windows binaries to JavaScript, .NET, Python, and even Motorola 68k Macintosh. I finished 185th out of 494 finishers and 5,345 participants which took me just over 2 weeks. I hope to finish higher/faster next year, providing I can allocate more time.\nIn this blogpost I will walk through my solution of my favorite challenge of this year. It is not necessarily the best, fastest or most complete solution, but I hope to show the difficulties we face during reversing. Also note that I omit all dead ends and rabbit holes I took which makes it seem I am a god, which I‚Äôm obviously not.\nThe challenge When we get to #09 we are greeted with the following encouraging message. The description does not hint us to anything except that we may be dealing with some cryptography. Note that the description is not that diminishing as the description of challenge #05 üò≠:\n FLARE FACT #823: Studies show that C++ Reversers have fewer friends on average than normal people do. That‚Äôs why you‚Äôre here, reversing this, instead of with them, because they don‚Äôt exist.\n Anyway, if you want to follow me along, you can download the challenge archive from the Flare-On website. Let‚Äôs start.\nInitial Triage When extracted we are presented with two files, flareon.exe and SuspiciousFile.txt.Encrypted. DIE tells us that we are dealing with a 64 bit PE executable (not packed). Running the binary without any arguments prints the usage: usage: flareon path [path ...].\nInspecting the encrypted file with a hexeditor reveals some interesting stuff. The file is composed of a 0x49 byte data block - that is of high entropy - concatenated with four hexstrings representing 128 bytes (split by a newline character 0x0a). Looking into the strings of the binary, we find the following.\n~*~*~* The FLARE-ON Encryptor ~*~*~* All your files have been encrypted with a powerful combination of symmetric and asymmetric cryptography. Do not tamper with the encrypted files. It is of no use and will only risk corrupting your data. To get your files decrypted send lots of cryptocurrency over Tor. You'll need to copy and paste us these values to get your key. Let‚Äôs hypothesize. The binary is used to encrypt the contents of SuspiciousFile.txt which gets written to SuspiciousFile.txt.Encrypted. If we are able to reverse the binary we can use that knowledge to recover the contents of the unencrypted SuspiciousFile.txt (which highly likely contains the flag). We should expect to see at least one symmetric cipher and one asymmetric cipher.\nStatic Analysis - Control Flow Let‚Äôs use the ‚Äòusage‚Äô string to see what the top-level function could be. We check the references to the string and find sub_3BF0. See control flow diagram below. This function first looks up the address of RtlGenRandom function using LoadLibraryA on ‚Äúadvapi32‚Äù and then GetProcAddress on ‚ÄúSystemFunction036‚Äù. Next, it calls sub_21D0 which has a lot of nested calls that do not call WinAPIs. Together with the fact that no content has been loaded hints me that this may be some key schedule. Next, it loops over all arguments and checks if these strings are appended with ‚Äú.EncryptMe‚Äù. If so, it opens it and opens another file for writing (original filename without ‚Äú.EncryptMe‚Äù, appended with ‚Äú.Encrypted‚Äù) and calls sub_22A3 with the fileptrs of these open files. This function presumably does the encryption and reads the .EncryptMe file and writes the .Encrypted file. Next, the loop closes both fileptrs and when there are no more arguments left, it prints how many files it encrypted. Following, if it encrypted files, it calls sub_239B which seems to write HOW_TO_DECRYPT.txt with the aforementioned contents that state how to get the decrypted (or unencrypted) files back.\nDynamic Analysis - Making assumptions Now that we know how we can encrypt files, let‚Äôs play with the binary to see if we can make any assumptions. We create a file test.txt.EncryptMe with contents ‚ÄúA‚Äù and supply it to the flareon.exe binary. We get feedback that the file has been encrypted. We compare SuspiciousFile.txt.Encrypted with test.txt.Encrypted and notice that the first block of 0x49 bytes has been decreased to 1 byte, which is equal to the amount of bytes supplied in the test.txt.EncryptMe file! This hints us that for the symmetric cipher we are probably dealing with a stream cipher instead of a block cipher. Also, we notice that the first hexstring is the same, the other three differ. For the malware, this may be a hardcoded campaign ID used by the malware author to distinguish between campaigns (the value may also be used as a parameter in the encryption). In fact, the hexstring is also written to the HOW_TO_DECRYPT.txt file which strengthens this assumption. Both the second and third hexstring are also written to this file. The fourth is not.\nStatic Analysis - Encryption Now that we have made some assumptions, let‚Äôs dive deeper in sub_22A3 which presumably does the encryption (we leave the nested calls for later). At the end of this function we see that the four hexstrings split with 0x0a that we previously saw from analyzing SuspiciousFile.txt.Encrypted are written to the fileptr .Encrypted. At offset 0x2321 we see the hardcoded first hexstring that starts with ‚Äú9f18776b‚Ä¶‚Äù. At offset 0x2340 we see the hexstring unk_9100. From inspecting the xrefs we find that this is probably set by the assumed key schedule function sub_21D0. Same holds for the third hexstring at offset 0x235c. The fourth hexstring at offset 0x2375 is probably the result of sub_16CC.\nMoving back to the beginning of the function, we notice that two buffers are populated with respectively 0x20 and 0xc random bytes using RtlGenRandom. Both of these buffers are passed to sub_20F0 along with the fileptrs to .EncryptMe and .Encrypted. This is highly likely the symmetric cipher which we assumed to be a stream cipher.\nAfter, we see that sub_16CC is called with an empty buffer rbp, the random buffer(s) used in sub_20F0 (highly likely symmetric cipher) and unknown buffers unk_4020 and unk_9100 which are likely set by sub_21D0. The latter of which is stored to the encrypted file as the second hexstring.\nTime for some more hypotheses. The assumed symmetric cipher sub_20F0 uses the random buffers of length 0x20 and 0xc as key and possibly IV or nonce. The result is probably written to the .Encrypted file. The function sub_16CC could be the asymmetric cipher that encrypts the key (and IV or nonce) using the buffers unk_4020 and unk_9100. The latter and the result of the encryption is written to the .Encrypted file. If so, we may be able to recover the key (and IV or nonce) used in the symmetric encryption.\nLet‚Äôs dive deeper into the two ciphers.\nSymmetric Cipher When we try to reverse sub_20F0 we only see one instruction. There must be more. In IDA, we press [SPACE] to view the inline assembly and indeed see the rest of the function one instruction further that was wrongly recognized as a function. We undefine both functions by pressing u on their first instructions and press p on the first instruction (offset 0x20f0) to define the entire function. That is better. We notice two QWORDs that seem to include ASCII, we change their type to a string and notice that it says ‚Äúexpand 3‚Äù and ‚Äú2-byte k‚Äù. A quick search on the internet shows that we may be dealing with Salsa20, which is in fact a stream cipher! If this is indeed Salsa20, we should easily recognize its core operation, the quarter-round function QR(a, b, c, d) with the distinctive rotate left (rol) instructions with operands 7, 9, 13, 18. This core operation is executed 8 times each round (20 rounds).\nb ^= (a + d)  7; c ^= (b + a)  9; d ^= (c + b)  13; a ^= (d + c)  18; We inspect sub_20F0 further and see that for every 0x40 bytes of the .EncryptMe file the function calls sub_1F10 and xors the results with the input buffer and writes that to the fileptr .Encrypted. Diving into sub_1F10 we see a pattern of eight chunks that rotate some data with respectively 16, 12, 8 and 7 bytes. This looks like the eight quarter-rounds but the operands of the rotations do not match. Searching the web for these rotations, we find a variant of Salsa20: Chacha20.\nWe don‚Äôt need to write a proof of concept to confirm that it indeed is Chacha20 because we can just use the binary to decrypt ciphertexts, editing the input buffers dynamically (because the operations are symmetric). The most important thing is that the third and fourth argument to the function are the key and nonce, and that the second argument holds the fileptr to the plaintext (.EncryptMe) and the first argument holds the fileptr to the resulting ciphertext (.Encrypted).\nLet‚Äôs move to the presumed asymmetric cipher in sub_16CC.\nAsymmetric Cipher The function sub_16CC itself is not all that large or deep, but the exotic instructions tell me we should probably not reverse this. We‚Äôll dynamically analyze this later. Moreover, the function is called in the previously assumed ‚Äòkey schedule function‚Äô sub_21D0 which tells us that that function probably does something else.\nAsymmetric cryptography is built on the fact that computations in one direction are easy, but really hard the other way around. For example, it could be built on the difficulty of factoring integers (RSA, DSA), or on the discrete logarithm problem (ECC, DSA).\nRSA is often used as a text-book example of asymmetric cryptography for its ‚Äòsimplicity‚Äô. So for now, let‚Äôs assume that sub_16CC is RSA because DSA and especially ECC are more complex.\nDynamic Analysis - Asymmetric Cipher To test our assumption we dynamically analyze sub_16CC. We run flareon.exe under WinDbg and break at flareon+231c where the call to sub_16CC is. We change the input buffers rdx to all zeroes and leave the others as-is. We notice that the output buffer contains zeroes. Great news because C = 0e mod n = 0 and C = Me mod 0 is undefined (function may return zeroes, we don‚Äôt know).\nNext run, we edit the buffer of the third argument r8 to all zeroes and leave the others as-is. The output now contains a single byte 0x01. Even better news because C = M0 mod n = 1. This means that highly likely rdx points to the buffer M containing the Chacha20 key and nonce, r8 points to buffer e containing the public exponent and r9 points to buffer n containing the modulus.\nTo confirm that sub_16CC is indeed RSA we test it using this text-book example. We run the debugger again and edit the buffer rdx to 0x02, r8 to 0x07 and r9 to 0x21 (33). The resulting buffer is 0x1d (29) which is what we expected: C = 27 mod 33 = 29. We confirmed sub_16CC is indeed RSA.\nRecovering the plaintext Now that we know which algorithms are used we can look into how we can recover the key and nonce which were used to encrypt the plaintext contents of SuspiciousFile.txt. Recall that the fourth argument (n, second hexstring) to the RSA function and the resulting buffer (C, fourth hexstring) is written to the .Encrypted file. In order to recover M we have to calculate M = Cd mod n. d, the private exponent is unknown. We could reverse the presumed ‚Äòkey schedule‚Äô function sub_21D0 (which obviously is not a key schedule function anymore üòù), or we can try to attack the public exponent in the hopes of finding the private exponent. One of the most well known attacks against the public exponent of RSA is Wiener‚Äôs Attack. Let‚Äôs try that.\nWiener‚Äôs attack We run the debugger again, break at flareon+231c where the call to sub_16CC is and copy the third argument buffer (e) and fourth argument buffer (n) for the attack. We find a nice Github repo by Nao Yonashiro that does the job for us. To our surprise they used 0x10001 as a weak private exponent! We can use this to decrypt the fourth hexstring in the .Encrypted file C which will give us the key and nonce used in the Chacha20 encryption.\nDecryption Now it is time to combine all the work.\nRSA The RSA decryption is very straight forward now: M = Cd mod n. We copy the fourth hexstring of the SuspiciousFile.txt.Encrypted and use it as the ciphertext C. We use 0x10001 as the private exponent d and copy the second hexstring to use as the modulo n. We decrypt using the native Python function pow(C, d, n) and see that the resulting plaintext M has the format of the Chacha20 key and nonce (in reverse order). Chacha20 Because Chacha20 is symmetric we‚Äôll use the flareon.exe binary to do the decryption for us. We copy the SuspiciousFile.txt.Encrypted to result.txt.EncryptMe and remove all bytes but the first 0x49. We run the debugger and break at flareon+2303 where the call to the Chacha20 function is. We modify the third argument buffer r8 to the recovered key and the fourth argument buffer r9 to the recovered nonce. We continue execution and should see the result in result.txt.Encrypted. Solution We inspect result.txt.Encrypted and indeed, we succeeded! ü•≥üéâ ","wordCount":"2246","inLanguage":"en","image":"https://gar-re.github.io/posts/flareon9-9/cover.png","datePublished":"2022-11-12T00:00:00Z","dateModified":"2022-11-12T00:00:00Z","author":{"@type":"Person","name":"Gary"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gar-re.github.io/posts/flareon9-9/"},"publisher":{"@type":"Organization","name":"Gar Reversing","logo":{"@type":"ImageObject","url":"https://gar-re.github.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://gar-re.github.io/ accesskey=h title="Gar Reversing (Alt + H)">
<img src=https://gar-re.github.io/gar-re_logo.png alt aria-label=logo height=35>Gar Reversing</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://gar-re.github.io/contact/ title=Contact>
<span>Contact</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/disclosure-policy/ title="Disclosure Policy">
<span>Disclosure Policy</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Flare-On 9: 09_encryptor
</h1>
<div class=post-meta><span title="2022-11-12 00:00:00 +0000 UTC">November 12, 2022</span>&nbsp;¬∑&nbsp;11 min&nbsp;¬∑&nbsp;Gary
</div>
</header>
<figure class=entry-cover>
<img loading=lazy srcset="https://gar-re.github.io/posts/flareon9-9/cover_huf61655263d4beb217ab05747bfd4a6c7_397207_360x0_resize_box_3.png 360w ,https://gar-re.github.io/posts/flareon9-9/cover_huf61655263d4beb217ab05747bfd4a6c7_397207_480x0_resize_box_3.png 480w ,https://gar-re.github.io/posts/flareon9-9/cover_huf61655263d4beb217ab05747bfd4a6c7_397207_720x0_resize_box_3.png 720w ,https://gar-re.github.io/posts/flareon9-9/cover_huf61655263d4beb217ab05747bfd4a6c7_397207_1080x0_resize_box_3.png 1080w ,https://gar-re.github.io/posts/flareon9-9/cover_huf61655263d4beb217ab05747bfd4a6c7_397207_1500x0_resize_box_3.png 1500w ,https://gar-re.github.io/posts/flareon9-9/cover.png 2680w" sizes="(min-width: 768px) 720px, 100vw" src=https://gar-re.github.io/posts/flareon9-9/cover.png alt width=2680 height=560>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#the-challenge aria-label="The challenge">The challenge</a></li>
<li>
<a href=#initial-triage aria-label="Initial Triage">Initial Triage</a></li>
<li>
<a href=#static-analysis---control-flow aria-label="Static Analysis - Control Flow">Static Analysis - Control Flow</a></li>
<li>
<a href=#dynamic-analysis---making-assumptions aria-label="Dynamic Analysis - Making assumptions">Dynamic Analysis - Making assumptions</a></li>
<li>
<a href=#static-analysis---encryption aria-label="Static Analysis - Encryption">Static Analysis - Encryption</a><ul>
<li>
<a href=#symmetric-cipher aria-label="Symmetric Cipher">Symmetric Cipher</a></li>
<li>
<a href=#asymmetric-cipher aria-label="Asymmetric Cipher">Asymmetric Cipher</a></li></ul>
</li>
<li>
<a href=#dynamic-analysis---asymmetric-cipher aria-label="Dynamic Analysis - Asymmetric Cipher">Dynamic Analysis - Asymmetric Cipher</a></li>
<li>
<a href=#recovering-the-plaintext aria-label="Recovering the plaintext">Recovering the plaintext</a><ul>
<li>
<a href=#wieners-attack aria-label="Wiener&amp;rsquo;s attack">Wiener&rsquo;s attack</a></li>
<li>
<a href=#decryption aria-label=Decryption>Decryption</a><ul>
<li>
<a href=#rsa aria-label=RSA>RSA</a></li>
<li>
<a href=#chacha20 aria-label=Chacha20>Chacha20</a></li></ul>
</li></ul>
</li>
<li>
<a href=#solution aria-label=Solution>Solution</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><a href=http://flare-on.com>Flare-On</a> is an annual single player reverse engineering CTF that represents the skills and challenges that the Mandiant FLARE team faces. The 8-12 challenges increase in difficulty and participants have about 6 weeks to complete them all in order to win a prize.</p>
<p>This year&rsquo;s contest included 11 challenges ranging from Windows binaries to JavaScript, .NET, Python, and even Motorola 68k Macintosh. I finished 185th out of <a href=https://www.mandiant.com/resources/blog/flareon9-challenge-solutions>494 finishers and 5,345 participants</a> which took me just over 2 weeks. I hope to finish higher/faster next year, providing I can allocate more time.</p>
<p><p align=center>
<img loading=lazy src=solves.png alt=solves.png>
</p>
</p>
<p>In this blogpost I will walk through my solution of my favorite challenge of this year. It is not necessarily the best, fastest or most complete solution, but I hope to show the difficulties we face during reversing. Also note that I omit all dead ends and rabbit holes I took which makes it seem I am a god, which I&rsquo;m obviously not.</p>
<h2 id=the-challenge>The challenge<a hidden class=anchor aria-hidden=true href=#the-challenge>#</a></h2>
<p>When we get to #09 we are greeted with the following encouraging message. The description does not hint us to anything except that we may be dealing with some cryptography.
<p align=center>
<img loading=lazy src=description.png alt=09_encryptor.7z>
</p>
Note that the description is not that diminishing as the description of challenge #05 üò≠:</p>
<blockquote>
<p>FLARE FACT #823: Studies show that C++ Reversers have fewer friends on average than normal people do. That&rsquo;s why you&rsquo;re here, reversing this, instead of with them, because they don&rsquo;t exist.</p>
</blockquote>
<p>Anyway, if you want to follow me along, you can download the challenge archive from the <a href=http://flare-on.com/files/Flare-On9_Challenges.zip>Flare-On website</a>. Let&rsquo;s start.</p>
<h2 id=initial-triage>Initial Triage<a hidden class=anchor aria-hidden=true href=#initial-triage>#</a></h2>
<p>When extracted we are presented with two files, <code>flareon.exe</code> and <code>SuspiciousFile.txt.Encrypted</code>. <a href=https://github.com/horsicq/Detect-It-Easy>DIE</a> tells us that we are dealing with a 64 bit PE executable (not packed). Running the binary without any arguments prints the usage: <code>usage: flareon path [path ...]</code>.</p>
<p>Inspecting the encrypted file with a hexeditor reveals some interesting stuff. The file is composed of a 0x49 byte data block - that is of high entropy - concatenated with four hexstrings representing 128 bytes (split by a newline character <code>0x0a</code>).
<p align=center>
<img loading=lazy src=hxd-encrypted.png alt=hxd-encrypted.png>
</p>
</p>
<p>Looking into the strings of the binary, we find the following.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>~*~*~* The FLARE-ON Encryptor ~*~*~*

All your files have been encrypted with a powerful combination of
symmetric and asymmetric cryptography. Do not tamper with the encrypted files.
It is of no use and will only risk corrupting your data.

To get your files decrypted send lots of cryptocurrency over Tor.

You&#39;ll need to copy and paste us these values to get your key.
</code></pre></div><p>Let&rsquo;s hypothesize. The binary is used to encrypt the contents of <code>SuspiciousFile.txt</code> which gets written to <code>SuspiciousFile.txt.Encrypted</code>. If we are able to reverse the binary we can use that knowledge to recover the contents of the unencrypted <code>SuspiciousFile.txt</code> (which highly likely contains the flag). We should expect to see at least one symmetric cipher and one asymmetric cipher.</p>
<h2 id=static-analysis---control-flow>Static Analysis - Control Flow<a hidden class=anchor aria-hidden=true href=#static-analysis---control-flow>#</a></h2>
<p>Let&rsquo;s use the &lsquo;usage&rsquo; string to see what the top-level function could be. We check the references to the string and find <code>sub_3BF0</code>. See control flow diagram below. This function first looks up the address of <a href=https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom><code>RtlGenRandom</code></a> function using <code>LoadLibraryA</code> on &ldquo;advapi32&rdquo; and then <code>GetProcAddress</code> on &ldquo;SystemFunction036&rdquo;. Next, it calls <code>sub_21D0</code> which has a lot of nested calls that do not call WinAPIs. Together with the fact that no content has been loaded hints me that this may be some <a href=https://en.wikipedia.org/wiki/Key_schedule>key schedule</a>.
Next, it loops over all arguments and checks if these strings are appended with &ldquo;.EncryptMe&rdquo;. If so, it opens it and opens another file for writing (original filename without &ldquo;.EncryptMe&rdquo;, appended with &ldquo;.Encrypted&rdquo;) and calls <code>sub_22A3</code> with the fileptrs of these open files. This function presumably does the encryption and reads the <code>.EncryptMe</code> file and writes the <code>.Encrypted</code> file. Next, the loop closes both fileptrs and when there are no more arguments left, it prints how many files it encrypted. Following, if it encrypted files, it calls <code>sub_239B</code> which seems to write <code>HOW_TO_DECRYPT.txt</code> with the aforementioned contents that state how to get the decrypted (or unencrypted) files back.</p>
<p><p align=center>
<img loading=lazy src=controlflow.png alt=controlflow.png>
</p>
</p>
<h2 id=dynamic-analysis---making-assumptions>Dynamic Analysis - Making assumptions<a hidden class=anchor aria-hidden=true href=#dynamic-analysis---making-assumptions>#</a></h2>
<p>Now that we know how we can encrypt files, let&rsquo;s play with the binary to see if we can make any assumptions. We create a file <code>test.txt.EncryptMe</code> with contents &ldquo;A&rdquo; and supply it to the <code>flareon.exe</code> binary. We get feedback that the file has been encrypted. We compare <code>SuspiciousFile.txt.Encrypted</code> with <code>test.txt.Encrypted</code> and notice that the first block of 0x49 bytes has been decreased to 1 byte, which is equal to the amount of bytes supplied in the <code>test.txt.EncryptMe</code> file! This hints us that for the symmetric cipher we are probably dealing with a <a href=https://en.wikipedia.org/wiki/Stream_cipher>stream cipher</a> instead of a <a href=https://en.wikipedia.org/wiki/Block_cipher>block cipher</a>.
Also, we notice that the first hexstring is the same, the other three differ. For the malware, this may be a hardcoded campaign ID used by the malware author to distinguish between campaigns (the value may also be used as a parameter in the encryption). In fact, the hexstring is also written to the <code>HOW_TO_DECRYPT.txt</code> file which strengthens this assumption. Both the second and third hexstring are also written to this file. The fourth is not.</p>
<p><p align=center>
<img loading=lazy src=bindiff.png alt=bindiff.png>
</p>
</p>
<h2 id=static-analysis---encryption>Static Analysis - Encryption<a hidden class=anchor aria-hidden=true href=#static-analysis---encryption>#</a></h2>
<p>Now that we have made some assumptions, let&rsquo;s dive deeper in <code>sub_22A3</code> which presumably does the encryption (we leave the nested calls for later). At the end of this function we see that the four hexstrings split with 0x0a that we previously saw from analyzing <code>SuspiciousFile.txt.Encrypted</code> are written to the fileptr <code>.Encrypted</code>. At offset 0x2321 we see the hardcoded first hexstring that starts with &ldquo;9f18776b&mldr;&rdquo;. At offset 0x2340 we see the hexstring <code>unk_9100</code>. From inspecting the xrefs we find that this is probably set by the assumed key schedule function <code>sub_21D0</code>. Same holds for the third hexstring at offset 0x235c. The fourth hexstring at offset 0x2375 is probably the result of <code>sub_16CC</code>.</p>
<p>Moving back to the beginning of the function, we notice that two buffers are populated with respectively 0x20 and 0xc random bytes using <code>RtlGenRandom</code>. Both of these buffers are passed to <code>sub_20F0</code> along with the fileptrs to <code>.EncryptMe</code> and <code>.Encrypted</code>. This is highly likely the symmetric cipher which we assumed to be a stream cipher.</p>
<p>After, we see that <code>sub_16CC</code> is called with an empty buffer <code>rbp</code>, the random buffer(s) used in <code>sub_20F0</code> (highly likely symmetric cipher) and unknown buffers <code>unk_4020</code> and <code>unk_9100</code> which are likely set by <code>sub_21D0</code>. The latter of which is stored to the encrypted file as the second hexstring.</p>
<p><p align=center>
<img loading=lazy src=static-encrypt.png alt=static-encrypt.png>
</p>
</p>
<p>Time for some more hypotheses. The assumed symmetric cipher <code>sub_20F0</code> uses the random buffers of length 0x20 and 0xc as key and possibly IV or nonce. The result is probably written to the <code>.Encrypted</code> file. The function <code>sub_16CC</code> could be the asymmetric cipher that encrypts the key (and IV or nonce) using the buffers <code>unk_4020</code> and <code>unk_9100</code>. The latter and the result of the encryption is written to the <code>.Encrypted</code> file. If so, we may be able to recover the key (and IV or nonce) used in the symmetric encryption.</p>
<p>Let&rsquo;s dive deeper into the two ciphers.</p>
<h3 id=symmetric-cipher>Symmetric Cipher<a hidden class=anchor aria-hidden=true href=#symmetric-cipher>#</a></h3>
<p>When we try to reverse <code>sub_20F0</code> we only see one instruction. There must be more. In IDA, we press <code>[SPACE]</code> to view the inline assembly and indeed see the rest of the function one instruction further that was wrongly recognized as a function. We undefine both functions by pressing <code>u</code> on their first instructions and press <code>p</code> on the first instruction (offset 0x20f0) to define the entire function.
<p align=center>
<img loading=lazy src=sub20f0small.png alt=sub20f0small.png>
</p>
That is better. We notice two <code>QWORDs</code> that seem to include ASCII, we change their type to a string and notice that it says &ldquo;expand 3&rdquo; and &ldquo;2-byte k&rdquo;. A quick search on the internet shows that we may be dealing with <a href=https://en.wikipedia.org/wiki/Salsa20>Salsa20</a>, which is in fact a stream cipher!
<p align=center>
<img loading=lazy src=sub20f0start.png alt=sub20f0start.png>
</p>
If this is indeed Salsa20, we should easily recognize its core operation, the quarter-round function <code>QR(a, b, c, d)</code> with the distinctive rotate left (<code>rol</code>) instructions with operands 7, 9, 13, 18. This core operation is executed 8 times each round (20 rounds).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>b <span style=color:#f92672>^=</span> (a <span style=color:#f92672>+</span> d) <span style=color:#f92672>&lt;&lt;&lt;</span> <span style=color:#ae81ff>7</span>;
c <span style=color:#f92672>^=</span> (b <span style=color:#f92672>+</span> a) <span style=color:#f92672>&lt;&lt;&lt;</span> <span style=color:#ae81ff>9</span>;
d <span style=color:#f92672>^=</span> (c <span style=color:#f92672>+</span> b) <span style=color:#f92672>&lt;&lt;&lt;</span> <span style=color:#ae81ff>13</span>;
a <span style=color:#f92672>^=</span> (d <span style=color:#f92672>+</span> c) <span style=color:#f92672>&lt;&lt;&lt;</span> <span style=color:#ae81ff>18</span>;
</code></pre></div><p>We inspect <code>sub_20F0</code> further and see that for every 0x40 bytes of the <code>.EncryptMe</code> file the function calls <code>sub_1F10</code> and xors the results with the input buffer and writes that to the fileptr <code>.Encrypted</code>. Diving into <code>sub_1F10</code> we see a pattern of eight chunks that rotate some data with respectively 16, 12, 8 and 7 bytes. This looks like the eight quarter-rounds but the operands of the rotations do not match. Searching the web for these rotations, we find a variant of Salsa20: Chacha20.</p>
<p><p align=center>
<img loading=lazy src=sub1f10.png alt=sub1f10.png>
</p>
</p>
<p>We don&rsquo;t need to write a proof of concept to confirm that it indeed is Chacha20 because we can just use the binary to decrypt ciphertexts, editing the input buffers dynamically (because the operations are symmetric). The most important thing is that the third and fourth argument to the function are the key and nonce, and that the second argument holds the fileptr to the plaintext (<code>.EncryptMe</code>) and the first argument holds the fileptr to the resulting ciphertext (<code>.Encrypted</code>).</p>
<p>Let&rsquo;s move to the presumed asymmetric cipher in <code>sub_16CC</code>.</p>
<h3 id=asymmetric-cipher>Asymmetric Cipher<a hidden class=anchor aria-hidden=true href=#asymmetric-cipher>#</a></h3>
<p>The function <code>sub_16CC</code> itself is not all that large or deep, but the exotic instructions tell me we should probably not reverse this. We&rsquo;ll dynamically analyze this later. Moreover, the function is called in the previously assumed &lsquo;key schedule function&rsquo; <code>sub_21D0</code> which tells us that that function probably does something else.</p>
<p>Asymmetric cryptography is built on the fact that computations in one direction are easy, but really hard the other way around. For example, it could be built on the difficulty of factoring integers (RSA, DSA), or on the discrete logarithm problem (ECC, DSA).</p>
<p>RSA is often used as a <a href=https://www.cs.utexas.edu/~mitra/honors/soln.html>text-book example</a> of asymmetric cryptography for its &lsquo;simplicity&rsquo;. So for now, let&rsquo;s assume that <code>sub_16CC</code> is RSA because DSA and especially ECC are more complex.</p>
<p><p align=center>
<img loading=lazy src=sub16cc.png alt=sub16cc.png>
</p>
</p>
<h2 id=dynamic-analysis---asymmetric-cipher>Dynamic Analysis - Asymmetric Cipher<a hidden class=anchor aria-hidden=true href=#dynamic-analysis---asymmetric-cipher>#</a></h2>
<p>To test our assumption we dynamically analyze <code>sub_16CC</code>. We run <code>flareon.exe</code> under WinDbg and break at <code>flareon+231c</code> where the call to <code>sub_16CC</code> is. We change the input buffers <code>rdx</code> to all zeroes and leave the others as-is. We notice that the output buffer contains zeroes. Great news because <em>C = 0<sup>e</sup> mod n = 0</em> and <em>C = M<sup>e</sup> mod 0</em> is undefined (function may return zeroes, we don&rsquo;t know).</p>
<p><p align=center>
<img loading=lazy src=rsadynamic1.png alt=rsadynamic1.png>
</p>
</p>
<p>Next run, we edit the buffer of the third argument <code>r8</code> to all zeroes and leave the others as-is. The output now contains a single byte <code>0x01</code>. Even better news because <em>C = M<sup>0</sup> mod n = 1</em>. This means that highly likely <code>rdx</code> points to the buffer <em>M</em> containing the Chacha20 key and nonce, <code>r8</code> points to buffer <code>e</code> containing the public exponent and <code>r9</code> points to buffer <code>n</code> containing the modulus.</p>
<p><p align=center>
<img loading=lazy src=rsadynamic2.png alt=rsadynamic2.png>
</p>
</p>
<p>To confirm that <code>sub_16CC</code> is indeed RSA we test it using this <a href=https://www.cs.utexas.edu/~mitra/honors/soln.html>text-book example</a>. We run the debugger again and edit the buffer <code>rdx</code> to 0x02, <code>r8</code> to 0x07 and <code>r9</code> to 0x21 (33). The resulting buffer is 0x1d (29) which is what we expected: <em>C = 2<sup>7</sup> mod 33 = 29</em>. We confirmed <code>sub_16CC</code> is indeed RSA.</p>
<p><p align=center>
<img loading=lazy src=rsadynamic3.png alt=rsadynamic3.png>
</p>
</p>
<h2 id=recovering-the-plaintext>Recovering the plaintext<a hidden class=anchor aria-hidden=true href=#recovering-the-plaintext>#</a></h2>
<p>Now that we know which algorithms are used we can look into how we can recover the key and nonce which were used to encrypt the plaintext contents of <code>SuspiciousFile.txt</code>. Recall that the fourth argument (<code>n</code>, second hexstring) to the RSA function and the resulting buffer (<code>C</code>, fourth hexstring) is written to the <code>.Encrypted</code> file. In order to recover <code>M</code> we have to calculate <em>M = C<sup>d</sup> mod n</em>. <code>d</code>, the private exponent is unknown. We could reverse the presumed &lsquo;key schedule&rsquo; function <code>sub_21D0</code> (which obviously is not a key schedule function anymore üòù), or we can try to attack the public exponent in the hopes of finding the private exponent. One of the most well known attacks against the public exponent of RSA is <a href=https://en.wikipedia.org/wiki/Wiener%27s_attack>Wiener&rsquo;s Attack</a>. Let&rsquo;s try that.</p>
<h3 id=wieners-attack>Wiener&rsquo;s attack<a hidden class=anchor aria-hidden=true href=#wieners-attack>#</a></h3>
<p>We run the debugger again, break at <code>flareon+231c</code> where the call to <code>sub_16CC</code> is and copy the third argument buffer (<code>e</code>) and fourth argument buffer (<code>n</code>) for the attack. We find a nice <a href=https://github.com/orisano/owiener>Github repo</a> by Nao Yonashiro that does the job for us. To our surprise they used 0x10001 as a weak private exponent! We can use this to decrypt the fourth hexstring in the <code>.Encrypted</code> file <code>C</code> which will give us the key and nonce used in the Chacha20 encryption.</p>
<p><p align=center>
<img loading=lazy src=wiener.png alt=wiener.png>
</p>
</p>
<h3 id=decryption>Decryption<a hidden class=anchor aria-hidden=true href=#decryption>#</a></h3>
<p>Now it is time to combine all the work.</p>
<h4 id=rsa>RSA<a hidden class=anchor aria-hidden=true href=#rsa>#</a></h4>
<p>The RSA decryption is very straight forward now: <em>M = C<sup>d</sup> mod n</em>. We copy the fourth hexstring of the <code>SuspiciousFile.txt.Encrypted</code> and use it as the ciphertext <code>C</code>. We use 0x10001 as the private exponent <code>d</code> and copy the second hexstring to use as the modulo <code>n</code>. We decrypt using the native Python function <code>pow(C, d, n)</code> and see that the resulting plaintext <code>M</code> has the format of the Chacha20 key and nonce (in reverse order).
<p align=center>
<img loading=lazy src=rsadecryption.png alt=rsadecryption.png>
</p>
</p>
<h4 id=chacha20>Chacha20<a hidden class=anchor aria-hidden=true href=#chacha20>#</a></h4>
<p>Because Chacha20 is symmetric we&rsquo;ll use the <code>flareon.exe</code> binary to do the decryption for us. We copy the <code>SuspiciousFile.txt.Encrypted</code> to <code>result.txt.EncryptMe</code> and remove all bytes but the first 0x49. We run the debugger and break at <code>flareon+2303</code> where the call to the Chacha20 function is. We modify the third argument buffer <code>r8</code> to the recovered key and the fourth argument buffer <code>r9</code> to the recovered nonce. We continue execution and should see the result in <code>result.txt.Encrypted</code>.
<p align=center>
<img loading=lazy src=chacha20decryption.png alt=chacha20decryption.png>
</p>
</p>
<h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2>
<p>We inspect <code>result.txt.Encrypted</code> and indeed, we succeeded! ü•≥üéâ
<p align=center>
<img loading=lazy src=solution.png alt=solution.png>
</p>
</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://gar-re.github.io/tags/flareon/>flareon</a></li>
<li><a href=https://gar-re.github.io/tags/writeup/>writeup</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Flare-On 9: 09_encryptor on twitter" href="https://x.com/intent/tweet/?text=Flare-On%209%3a%2009_encryptor&url=https%3a%2f%2fgar-re.github.io%2fposts%2fflareon9-9%2f&hashtags=flareon%2cwriteup"><svg id="svg5" xmlns:svg="http://www.w3.org/2000/svg" height="30" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1250 1150" fill="currentcolor"><path id="path1009" d="M283.94 167.31l386.39 516.64L281.5 1104h87.51l340.42-367.76L984.48 1104h297.8L874.15 558.3l361.92-390.99h-87.51l-313.51 338.7-253.31-338.7H283.94zm128.69 64.46h136.81l604.13 807.76h-136.81L412.63 231.77z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2025 <a href=https://gar-re.github.io/>Gar Reversing</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>