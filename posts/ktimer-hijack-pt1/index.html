<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Delaying Kernel Payloads by Hijacking KTIMERs & KDPCs (Part 1) | Gar Reversing</title>
<meta name=keywords content="post_exploitation,windows_internals">
<meta name=description content="In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads.
This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack KTIMER and KDCP objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.">
<meta name=author content="Gary">
<link rel=canonical href=https://gar-re.github.io/posts/ktimer-hijack-pt1/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.319f7209271a6127ecb9f000084aa4ce7f5f4394f5ef702b9cbb0f5bdd4523de.css integrity="sha256-MZ9yCScaYSfsufAACEqkzn9fQ5T173ArnLsPW91FI94=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gar-re.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://gar-re.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://gar-re.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://gar-re.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://gar-re.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript><meta property="og:title" content="Delaying Kernel Payloads by Hijacking KTIMERs & KDPCs (Part 1)">
<meta property="og:description" content="In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads.
This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack KTIMER and KDCP objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gar-re.github.io/posts/ktimer-hijack-pt1/">
<meta property="og:image" content="https://gar-re.github.io/posts/ktimer-hijack-pt1/cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2023-09-15T00:00:00+00:00">
<meta property="article:modified_time" content="2023-09-15T00:00:00+00:00"><meta property="og:site_name" content="Gar Reversing">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://gar-re.github.io/posts/ktimer-hijack-pt1/twittercard.png">
<meta name=twitter:title content="Delaying Kernel Payloads by Hijacking KTIMERs & KDPCs (Part 1)">
<meta name=twitter:description content="In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads.
This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack KTIMER and KDCP objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gar-re.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Delaying Kernel Payloads by Hijacking KTIMERs \u0026 KDPCs (Part 1)","item":"https://gar-re.github.io/posts/ktimer-hijack-pt1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Delaying Kernel Payloads by Hijacking KTIMERs \u0026 KDPCs (Part 1)","name":"Delaying Kernel Payloads by Hijacking KTIMERs \u0026 KDPCs (Part 1)","description":"In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads. This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack KTIMER and KDCP objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.\n","keywords":["post_exploitation","windows_internals"],"articleBody":"In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads. This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack KTIMER and KDCP objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.\nIntroduction We assume that an attacker has an arbitrary read/write primitive (ARW) in the kernel, which is usually the first objective in Windows Kernel Exploitation. The next step is often to “upgrade” this ARW to arbitrary code execution. Similarly to getting code execution by e.g. hijacking a kernel mode routine, the presented technique results in arbitrary code execution, but in a delayed manner (and periodic if necessary). This means that a “ticking time bomb” could live in the Windows kernel whilst the kernel exploit process is already terminated, making it harder to detect. Additionally, no Page Table Entries (PTE) have to be modified as the KDPC and KTIMER objects are already writeable, making it abide by the rules that HVCI has set.\nWe use the most recent Windows 11 22H2 (22621.2134, August 2023) at the time of our research as our target machine with default exploit mitigations in place but disabling HVCI if enabled. This is because HVCI will activate kCFG which will disallow the execution the hijacked DeferredRoutine (this will become more clear later on). We’ll make sure that the rest of the exploit is HVCI compliant, with an eventual kCFG bypass, KTIMER hijacking is also possible on machines that have HVCI enabled.\nFor this first part, we illustrate a proof of concept by reading and writing kernel data in a debugger, in the second part we implement this in a proof of concept taking all aspects of exploit development into account (stackpivotting, executing kernel mode routines and restoring the execution flow).\nAs far as I am aware, this research has not been carried out before, making KTIMER hijacking a novel post-exploitation technique.\nLet’s start!\nTimer Table Each processor has its own timer table for which it does its own timer expiration routine. These KTIMER_TABLE structures can be requested using the WinDbg !timer command in a (local) kernel debugger which can be seen in the following screenshot. We see the KTIMER_TABLE for processor 0 (yellow) and notice two arrays, one for high precision timers (type 0) and one for the standard timers (type 1). High precision timers are used for applications that require very fast response times, such as multimedia applications. In the table we see the addresses of the KTIMER objects, fire times and the Deferred Procedure Call (DPC) or threads to execute at this fire time. I’ll explain DPCs later, first we explain where these timer tables are stored in the kernel.\nThe Kernel Processor Control Region (KPCR) is a per-processor structure which contains information about the processor. It contains the Kernel Processor Control Block (KPRCB) structure which holds most of what the kernel needs for managing the processor and its resources. It is the KPRCB that contains a pointer to the processor’s KTIMER_TABLE. See following screenshot where we traverse the KPCR and KPRCB to find the KTIMER_TABLE at KPCR+0x180+0x3c00. At offset 0x200 in the KTIMER_TABLE two arrays are defined with each 256 KTIMER_TABLE_ENTRY elements. The first array corresponds to the high precision timers, and the second with the standard timers.\nTimer Entries Let’s take a step back to the output of the !timer command. In the table, three interesting timers are always present, namely the timer that checks for Daylight Savings Time time-zone changes, the timer that processes the passing of the year and the timer that processes the passing of the century as can be seen in the next screenshot. We’ll use this distinct timer (green) that processes the DPC (orange) calling the nt!ExpCenturyDpcRoutine (pink), it should be present at index 73 in the array for standard timers.\nRefer to the next screenshot. Inspecting TimerEntries[1][73] we notice that the KTIMER_TABLE_ENTRY holds a linked list at offset 0x8 s.t. it can hold multiple timers represented by the KTIMER structure. The KTIMER itself holds the LIST_ENTRY at offset 0x20 in the TimerListEntry member. We can use the WinDbg command !list to display the linked list and dump the KTIMER objects in the list. For this, we need to specify the name of the datastructure holding the forward link using -t, namely nt!_KTIMER.TimerListEntry.Flink. We specify the command to execute using -x, here @$extret is the variable that holds the current object in the list. In this case we print the address using ? and dump the KTIMER object. Next, we specify the address of the first KTIMER object, this is the Flink from the KTIMER_TABLE_ENTRY (cyan) minus 0x20, the offset of the LIST_ENTRY in the KTIMER structure. Notice that we indeed located the KTIMER object for the DPC routine handling the passing of the century (green), but the pointer to the DPC (red) is not the same as we previously identified (it should be orange). In fact, the pointer doesn’t even point to valid memory. We need to figure out how the kernel uses this value to find the actual DPC. This can be achieved with an access breakpoint, to explain this we first need to explain how timers expire.\nTimer Expiration As soon as timers are expired, the clock Interrupt Service Routine (ISR) sets the TimerRequest flag in the KPRCB so that the DPC draining mechanism knows DPCs are in queue to be executed. The DueTime in the KTIMER objects is the InterruptTime at which the corresponding KDPC.DeferredRoutine wants to be executed. We can calculate what exact date and time this is by subtracting the current InterruptTime from the SystemTime and adding the DueTime. Both the interrupt time and system time are present in the KUSER_SHARED_DATA, an object that the kernel places at a pre-set address for sharing with user-mode. For our build, KUSER_SHARED_DATA is still located at 0xfffff78000000000. See the following screenshot. Note that we have set both our debuggee as well as our debugger to UTC to stay away from conversions (TimeZoneBias is 0). We subtract the interrupt time from the system time and add the DueTime from our target KTIMER (green). The value is passed to .formats to see that the time is indeed at the passing of the century. Now we can figure out how the DPC in the KTIMER object is decrypted. Reversing KTIMER DPCs In order to figure out how the kernel decrypts the KTIMER.Dpc we need to know when it accesses this value. We set an access breakpoint ba of an 8-byte read r8 on a KTIMER object (blue, that is about to expire) at offset 0x30, this is the encrypted DPC. Continuing execution, we break at nt!KiTimerWaitTest+0x1d, which is actually one instruction further than where the read occurred. Disassembling backwards we see that the instruction at nt+0x345909 was responsible for the dereference.\nReversing this function in IDA we notice a decryption routine before the DPC is placed in rsi and used later in a call to KiInsertQueueDpc. The following screenshot contains annotations from the decryption routine. As can be seen, nt!KiWaitNever, nt!KiWaitAlways and a pointer to the KTIMER is used with various operations (xor, left rotation and byteswap).\nLet’s manually carry out this decryption in the debugger for our target KTIMER. The following screenshot once again dumps the target KTIMER. We list the values that are used in the decryption, nt!KiWaitNever (light pink) and nt!KiWaitAlways (light red). First, we xor the encrypted DPC (red) with nt!KiWaitNever (light pink). Next, we rotate left with 0x7b bytes with a gnarly looking expression, before xor’ing the result with the address of the KTIMER. We manually do the byteswap and xor that with nt!KiWaitAlways (light red). The result is the DPC that we initially found in the timer table (orange)!\nNow, let’s focus some more on DPCs before trying to hijack and delay the execution flow.\nDeferred Procedure Calls A Deferred Procedure Call (DPC) is an object that contains a function that will be deferred at Interrupt Request Level (IRQL) DISPATCH_LEVEL/DPC_LEVEL (level 2). These IRQLs define the hardware priority at which a processor operates at any given time. For example, the CLOCK_LEVEL is one of the highest because it needs to handle processor ticks. So, when the IRQL level drops to level 2, DPCs in the DPC queue will be executed, emptying the queue as it proceeds. Because the DPCs are deferred, they may not execute at the exact DueTime, the processor first has to execute all higher level interrupts. Microsoft mentions that the members of the KDPC structure may not be set directly. What if we do set them directly? What if we could set the DeferredRoutine to any function pointer and set the corresponding KTIMER.DueTime to a specific InterruptTime of our choosing? If possible we could be able to delay the execution of kernel mode payloads.\nProof of Concept We have shown how KTIMER objects can be traversed from the KPCR and how the encrypted DPC values can be decrypted. We have shown how the timers are processed and at which DueTime the DPCs fire. Also, both the KTIMER objects and and KDPC objects are writeable from the kernel as can be seen from the following screenshot. All that’s left is trying it out in the debugger. In the following screenshot we illustrate that KTIMER hijacking is feasible as a way to execute arbitrary function pointers. Although we manually modify values in the debugger, these values should be modifiable by a kernel exploit having an arbitrary read/write. We change the KDPC.DeferredRoutine to a bogus nop; ret; gadget before changing the KTIMER.DueTime to the current value of the KUSER_SHARED_DATA.InterruptTime s.t. it is directly placed in the DPC queue. Of course, the DueTime can be any value representing a date and time. We set a breakpoint on the bogus gadget before continuing execution. When the IRQL drops to DISPATCH_LEVEL the breakpoint is hit and we can execute the nop! A Note on PatchGuard PatchGuard is used by Windows to monitor the system for changes in the kernel, by the kernel. Because of this, PatchGuard is uniquely undocumented and implemented very vaguely and obscure as attackers may disable it when they come to know the internals.\nIn the proof of concept we did not have to deal with PatchGuard as it is disabled when enabling (local) kernel debugging. That said, PatchGuard DPCs are also triggered using timers, so it would be interesting to see whether PatchGuard actually monitors the timer table entries.\nThanks In the second part of the series we will implement the results of this research in a proof of concept, taking all aspects of exploit development into account. We’ll show how to bring your own vulnerable driver (BYOVD), use an arbitrary read/write to get a specific KTIMER, decrypt the KTIMER.Dpc, do the KTIMER hijack and execute an arbitrary kernel API. We also test our proof of concept against a build with PatchGuard enabled, running it for a longer time to see if we can draw some conclusions.\nI’d like to thank Yarden Shafir (@yarden_shafir) for pointing out this research topic during her Windows Internals course. If you like a crash course in Windows Internals it is worth checking out.\nThanks for taking the time to read this post. If you have any questions or remarks, reach out to me on X or Discord.\n","wordCount":"1917","inLanguage":"en","image":"https://gar-re.github.io/posts/ktimer-hijack-pt1/cover.png","datePublished":"2023-09-15T00:00:00Z","dateModified":"2023-09-15T00:00:00Z","author":{"@type":"Person","name":"Gary"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gar-re.github.io/posts/ktimer-hijack-pt1/"},"publisher":{"@type":"Organization","name":"Gar Reversing","logo":{"@type":"ImageObject","url":"https://gar-re.github.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://gar-re.github.io/ accesskey=h title="Gar Reversing (Alt + H)">
<img src=https://gar-re.github.io/gar-re_logo.png alt aria-label=logo height=35>Gar Reversing</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://gar-re.github.io/contact/ title=Contact>
<span>Contact</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/disclosure-policy/ title="Disclosure Policy">
<span>Disclosure Policy</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://gar-re.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Delaying Kernel Payloads by Hijacking KTIMERs & KDPCs (Part 1)
</h1>
<div class=post-meta><span title="2023-09-15 00:00:00 +0000 UTC">September 15, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Gary
</div>
</header>
<figure class=entry-cover>
<img loading=lazy srcset="https://gar-re.github.io/posts/ktimer-hijack-pt1/cover_hu27e1e1ddfd458a3503adbd6ca43c8349_158234_360x0_resize_box_3.png 360w ,https://gar-re.github.io/posts/ktimer-hijack-pt1/cover_hu27e1e1ddfd458a3503adbd6ca43c8349_158234_480x0_resize_box_3.png 480w ,https://gar-re.github.io/posts/ktimer-hijack-pt1/cover_hu27e1e1ddfd458a3503adbd6ca43c8349_158234_720x0_resize_box_3.png 720w ,https://gar-re.github.io/posts/ktimer-hijack-pt1/cover_hu27e1e1ddfd458a3503adbd6ca43c8349_158234_1080x0_resize_box_3.png 1080w ,https://gar-re.github.io/posts/ktimer-hijack-pt1/cover_hu27e1e1ddfd458a3503adbd6ca43c8349_158234_1500x0_resize_box_3.png 1500w ,https://gar-re.github.io/posts/ktimer-hijack-pt1/cover.png 2680w" sizes="(min-width: 768px) 720px, 100vw" src=https://gar-re.github.io/posts/ktimer-hijack-pt1/cover.png alt width=2680 height=560>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#introduction aria-label=Introduction>Introduction</a></li>
<li>
<a href=#timer-table aria-label="Timer Table">Timer Table</a></li>
<li>
<a href=#timer-entries aria-label="Timer Entries">Timer Entries</a></li>
<li>
<a href=#timer-expiration aria-label="Timer Expiration">Timer Expiration</a></li>
<li>
<a href=#reversing-ktimer-dpcs aria-label="Reversing KTIMER DPCs">Reversing KTIMER DPCs</a></li>
<li>
<a href=#deferred-procedure-calls aria-label="Deferred Procedure Calls">Deferred Procedure Calls</a></li>
<li>
<a href=#proof-of-concept aria-label="Proof of Concept">Proof of Concept</a></li>
<li>
<a href=#a-note-on-patchguard aria-label="A Note on PatchGuard">A Note on PatchGuard</a></li>
<li>
<a href=#thanks aria-label=Thanks>Thanks</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>In this two part blog post series we present KTIMER hijacking, a novel post-exploitation technique that delays the execution of kernel-mode payloads.
This first part will focus on Windows 11 timer internals and deferred procedure calls and how we can hijack <code>KTIMER</code> and <code>KDCP</code> objects to delay the execution of a function pointer. The second part focusses on implementing these findings in a proof of concept, illustrating the delay in execution of a kernel-mode payload.</p>
<h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2>
<p>We assume that an attacker has an arbitrary read/write primitive (ARW) in the kernel, which is usually the first objective in Windows Kernel Exploitation.
The next step is often to &ldquo;upgrade&rdquo; this ARW to arbitrary code execution.
Similarly to getting code execution by e.g. hijacking a kernel mode routine, the presented technique results in arbitrary code execution, but in a delayed manner (and periodic if necessary). This means that a &ldquo;ticking time bomb&rdquo; could live in the Windows kernel whilst the kernel exploit process is already terminated, making it harder to detect. Additionally, no Page Table Entries (PTE) have to be modified as the <code>KDPC</code> and <code>KTIMER</code> objects are already writeable, making it abide by the rules that HVCI has set.</p>
<p>We use the most recent Windows 11 22H2 <a href=https://support.microsoft.com/en-gb/topic/august-8-2023-kb5029263-os-build-22621-2134-f8d4d3de-47c1-40e1-a2e6-97c2770ee2e8>(22621.2134, August 2023)</a> at the time of our research as our target machine with default exploit mitigations in place but disabling HVCI if enabled.
This is because HVCI will activate kCFG which will disallow the execution the hijacked <code>DeferredRoutine</code> (this will become more clear later on).
We&rsquo;ll make sure that the rest of the exploit is HVCI compliant, with an eventual kCFG bypass, KTIMER hijacking is also possible on machines that have HVCI enabled.</p>
<p>For this first part, we illustrate a proof of concept by reading and writing kernel data in a debugger, in the second part we implement this in a proof of concept taking all aspects of exploit development into account (stackpivotting, executing kernel mode routines and restoring the execution flow).</p>
<p>As far as I am aware, this research has not been carried out before, making KTIMER hijacking a novel post-exploitation technique.</p>
<p>Let&rsquo;s start!</p>
<h2 id=timer-table>Timer Table<a hidden class=anchor aria-hidden=true href=#timer-table>#</a></h2>
<p>Each processor has its own timer table for which it does its own timer expiration routine. These <code>KTIMER_TABLE</code> structures can be requested using the WinDbg <code>!timer</code> command in a (local) kernel debugger which can be seen in the following screenshot. We see the <code>KTIMER_TABLE</code> for processor 0 (yellow) and notice two arrays, one for high precision timers (type 0) and one for the standard timers (type 1). High precision timers are used for applications that require very fast response times, such as multimedia applications. In the table we see the addresses of the <code>KTIMER</code> objects, fire times and the Deferred Procedure Call (DPC) or threads to execute at this fire time. I&rsquo;ll explain DPCs later, first we explain where these timer tables are stored in the kernel.</p>
<p><p align=center>
<img loading=lazy src=timertable.png alt=KTIMER_TABLE>
</p>
</p>
<p>The Kernel Processor Control Region (KPCR) is a per-processor structure which contains information about the processor.
It contains the Kernel Processor Control Block (KPRCB) structure which holds most of what the kernel needs for managing the processor and its resources. It is the <code>KPRCB</code> that contains a pointer to the processor&rsquo;s <code>KTIMER_TABLE</code>. See following screenshot where we traverse the <code>KPCR</code> and <code>KPRCB</code> to find the <code>KTIMER_TABLE</code> at <code>KPCR+0x180+0x3c00</code>. At offset 0x200 in the <code>KTIMER_TABLE</code> two arrays are defined with each 256 <code>KTIMER_TABLE_ENTRY</code> elements. The first array corresponds to the high precision timers, and the second with the standard timers.</p>
<p><p align=center>
<img loading=lazy src=timerentries.png alt=@$pcr-&amp;gt;Prcb.TimerTable.TimerEntries>
</p>
</p>
<h2 id=timer-entries>Timer Entries<a hidden class=anchor aria-hidden=true href=#timer-entries>#</a></h2>
<p>Let&rsquo;s take a step back to the output of the <code>!timer</code> command. In the table, three interesting timers are always present, namely the timer that checks for Daylight Savings Time time-zone changes, the timer that processes the passing of the year and the timer that processes the passing of the century as can be seen in the next screenshot.
We&rsquo;ll use this distinct timer (green) that processes the DPC (orange) calling the <code>nt!ExpCenturyDpcRoutine</code> (pink), it should be present at index 73 in the array for standard timers.</p>
<p><p align=center>
<img loading=lazy src=timerentry.png alt="ExpCenturyDpcRoutine timer entry">
</p>
</p>
<p>Refer to the next screenshot. Inspecting <code>TimerEntries[1][73]</code> we notice that the <code>KTIMER_TABLE_ENTRY</code> holds a linked list at offset 0x8 s.t. it can hold multiple timers represented by the <code>KTIMER</code> structure.
The <code>KTIMER</code> itself holds the <code>LIST_ENTRY</code> at offset 0x20 in the <code>TimerListEntry</code> member.
We can use the WinDbg command <code>!list</code> to display the linked list and dump the <code>KTIMER</code> objects in the list.
For this, we need to specify the name of the datastructure holding the forward link using <code>-t</code>, namely <code>nt!_KTIMER.TimerListEntry.Flink</code>.
We specify the command to execute using <code>-x</code>, here <code>@$extret</code> is the variable that holds the current object in the list.
In this case we print the address using <code>?</code> and dump the <code>KTIMER</code> object.
Next, we specify the address of the first <code>KTIMER</code> object, this is the <code>Flink</code> from the <code>KTIMER_TABLE_ENTRY</code> (cyan) minus 0x20, the offset of the <code>LIST_ENTRY</code> in the <code>KTIMER</code> structure.
Notice that we indeed located the <code>KTIMER</code> object for the DPC routine handling the passing of the century (green), but the pointer to the DPC (red) is not the same as we previously identified (it should be orange).
In fact, the pointer doesn&rsquo;t even point to valid memory.
We need to figure out how the kernel uses this value to find the actual DPC.
This can be achieved with an access breakpoint, to explain this we first need to explain how timers expire.</p>
<p><p align=center>
<img loading=lazy src=ktimer.png alt="ExpCenturyDpcRoutine timer entry">
</p>
</p>
<h2 id=timer-expiration>Timer Expiration<a hidden class=anchor aria-hidden=true href=#timer-expiration>#</a></h2>
<p>As soon as timers are expired, the clock Interrupt Service Routine (ISR) sets the <code>TimerRequest</code> flag in the <code>KPRCB</code> so that the DPC draining mechanism knows DPCs are in queue to be executed.
The <code>DueTime</code> in the <code>KTIMER</code> objects is the <code>InterruptTime</code> at which the corresponding <code>KDPC.DeferredRoutine</code> wants to be executed.
We can calculate what exact date and time this is by subtracting the current <code>InterruptTime</code> from the <code>SystemTime</code> and adding the <code>DueTime</code>.
Both the interrupt time and system time are present in the <code>KUSER_SHARED_DATA</code>, an object that the kernel places at a pre-set address for sharing with user-mode.
For our build, <code>KUSER_SHARED_DATA</code> is still located at <code>0xfffff78000000000</code>.
See the following screenshot. Note that we have set both our debuggee as well as our debugger to UTC to stay away from conversions (<code>TimeZoneBias</code> is 0).
We subtract the interrupt time from the system time and add the <code>DueTime</code> from our target <code>KTIMER</code> (green).
The value is passed to <code>.formats</code> to see that the time is indeed at the passing of the century.
Now we can figure out how the DPC in the <code>KTIMER</code> object is decrypted.
<p align=center>
<img loading=lazy src=interrupttime.png alt="InterruptTime, SystemTime and DueTime">
</p>
</p>
<h2 id=reversing-ktimer-dpcs>Reversing KTIMER DPCs<a hidden class=anchor aria-hidden=true href=#reversing-ktimer-dpcs>#</a></h2>
<p>In order to figure out how the kernel decrypts the <code>KTIMER.Dpc</code> we need to know when it accesses this value.
We set an access breakpoint <code>ba</code> of an 8-byte read <code>r8</code> on a <code>KTIMER</code> object (blue, that is about to expire) at offset 0x30, this is the encrypted DPC.
Continuing execution, we break at <code>nt!KiTimerWaitTest+0x1d</code>, which is actually one instruction further than where the read occurred.
Disassembling backwards we see that the instruction at <code>nt+0x345909</code> was responsible for the dereference.</p>
<p><p align=center>
<img loading=lazy src=ba.png alt="Setting an access breakpoint on the encrypted DPC">
</p>
</p>
<p>Reversing this function in IDA we notice a decryption routine before the <code>DPC</code> is placed in <code>rsi</code> and used later in a call to <code>KiInsertQueueDpc</code>.
The following screenshot contains annotations from the decryption routine.
As can be seen, <code>nt!KiWaitNever</code>, <code>nt!KiWaitAlways</code> and a pointer to the <code>KTIMER</code> is used with various operations (xor, left rotation and byteswap).</p>
<p><p align=center>
<img loading=lazy src=ida.png alt="Reversing the decryption algorithm of the DPC">
</p>
</p>
<p>Let&rsquo;s manually carry out this decryption in the debugger for our target <code>KTIMER</code>.
The following screenshot once again dumps the target <code>KTIMER</code>.
We list the values that are used in the decryption, <code>nt!KiWaitNever</code> (light pink) and <code>nt!KiWaitAlways</code> (light red).
First, we xor the encrypted DPC (red) with <code>nt!KiWaitNever</code> (light pink).
Next, we rotate left with 0x7b bytes with a gnarly looking expression, before xor&rsquo;ing the result with the address of the <code>KTIMER</code>.
We manually do the byteswap and xor that with <code>nt!KiWaitAlways</code> (light red).
The result is the DPC that we initially found in the timer table (orange)!</p>
<p>Now, let&rsquo;s focus some more on DPCs before trying to hijack and delay the execution flow.</p>
<p><p align=center>
<img loading=lazy src=dpcdecryption.png alt="Decrypting the DPC">
</p>
</p>
<h2 id=deferred-procedure-calls>Deferred Procedure Calls<a hidden class=anchor aria-hidden=true href=#deferred-procedure-calls>#</a></h2>
<p>A Deferred Procedure Call (DPC) is an object that contains a function that will be deferred at Interrupt Request Level (IRQL) <code>DISPATCH_LEVEL</code>/<code>DPC_LEVEL</code> (level 2). These IRQLs define the hardware priority at which a processor operates at any given time. For example, the <code>CLOCK_LEVEL</code> is one of the highest because it needs to handle processor ticks. So, when the IRQL level drops to level 2, DPCs in the DPC queue will be executed, emptying the queue as it proceeds. Because the DPCs are deferred, they may not execute at the exact <code>DueTime</code>, the processor first has to execute all higher level interrupts. Microsoft <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess#kdpc>mentions</a> that the members of the <code>KDPC</code> structure may not be set directly. What if we do set them directly? What if we could set the <code>DeferredRoutine</code> to any function pointer and set the corresponding <code>KTIMER.DueTime</code> to a specific <code>InterruptTime</code> of our choosing? If possible we could be able to delay the execution of kernel mode payloads.</p>
<h2 id=proof-of-concept>Proof of Concept<a hidden class=anchor aria-hidden=true href=#proof-of-concept>#</a></h2>
<p>We have shown how <code>KTIMER</code> objects can be traversed from the <code>KPCR</code> and how the encrypted DPC values can be decrypted.
We have shown how the timers are processed and at which <code>DueTime</code> the DPCs fire.
Also, both the <code>KTIMER</code> objects and and <code>KDPC</code> objects are writeable from the kernel as can be seen from the following screenshot.
All that&rsquo;s left is trying it out in the debugger.
<p align=center>
<img loading=lazy src=pte.png alt="PTE for KTIMER and KDPC">
</p>
</p>
<p>In the following screenshot we illustrate that KTIMER hijacking is feasible as a way to execute arbitrary function pointers.
Although we manually modify values in the debugger, these values should be modifiable by a kernel exploit having an arbitrary read/write.
We change the <code>KDPC.DeferredRoutine</code> to a bogus <code>nop; ret;</code> gadget before changing the <code>KTIMER.DueTime</code> to the current value of the <code>KUSER_SHARED_DATA.InterruptTime</code> s.t. it is directly placed in the DPC queue.
Of course, the <code>DueTime</code> can be any value representing a date and time.
We set a breakpoint on the bogus gadget before continuing execution.
When the IRQL drops to <code>DISPATCH_LEVEL</code> the breakpoint is hit and we can execute the <code>nop</code>!
<p align=center>
<img loading=lazy src=proof.png alt="KTIMER hijacking proof of concept">
</p>
</p>
<h2 id=a-note-on-patchguard>A Note on PatchGuard<a hidden class=anchor aria-hidden=true href=#a-note-on-patchguard>#</a></h2>
<p>PatchGuard is used by Windows to monitor the system for changes in the kernel, by the kernel.
Because of this, PatchGuard is uniquely undocumented and implemented very vaguely and obscure as attackers may disable it when they come to know the internals.</p>
<p>In the proof of concept we did not have to deal with PatchGuard as it is disabled when enabling (local) kernel debugging.
That said, PatchGuard DPCs are also triggered using timers, so it would be interesting to see whether PatchGuard actually monitors the timer table entries.</p>
<h2 id=thanks>Thanks<a hidden class=anchor aria-hidden=true href=#thanks>#</a></h2>
<p>In the second part of the series we will implement the results of this research in a proof of concept, taking all aspects of exploit development into account.
We&rsquo;ll show how to bring your own vulnerable driver (BYOVD), use an arbitrary read/write to get a specific <code>KTIMER</code>, decrypt the <code>KTIMER.Dpc</code>, do the KTIMER hijack and execute an arbitrary kernel API. We also test our proof of concept against a build with PatchGuard enabled, running it for a longer time to see if we can draw some conclusions.</p>
<p>I&rsquo;d like to thank Yarden Shafir (<a href=https://twitter.com/yarden_shafir>@yarden_shafir</a>) for pointing out this research topic during her Windows Internals course.
If you like a crash course in <a href=https://windows-internals.com>Windows Internals</a> it is worth checking out.</p>
<p>Thanks for taking the time to read this post.
If you have any questions or remarks, reach out to me on <a href=https://x.com/gar_re>X</a> or <a href=https://discord.com/invite/offsec>Discord</a>.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://gar-re.github.io/tags/post_exploitation/>post_exploitation</a></li>
<li><a href=https://gar-re.github.io/tags/windows_internals/>windows_internals</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Delaying Kernel Payloads by Hijacking KTIMERs & KDPCs (Part 1) on twitter" href="https://x.com/intent/tweet/?text=Delaying%20Kernel%20Payloads%20by%20Hijacking%20KTIMERs%20%26%20KDPCs%20%28Part%201%29&url=https%3a%2f%2fgar-re.github.io%2fposts%2fktimer-hijack-pt1%2f&hashtags=post_exploitation%2cwindows_internals"><svg id="svg5" xmlns:svg="http://www.w3.org/2000/svg" height="30" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1250 1150" fill="currentcolor"><path id="path1009" d="M283.94 167.31l386.39 516.64L281.5 1104h87.51l340.42-367.76L984.48 1104h297.8L874.15 558.3l361.92-390.99h-87.51l-313.51 338.7-253.31-338.7H283.94zm128.69 64.46h136.81l604.13 807.76h-136.81L412.63 231.77z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2025 <a href=https://gar-re.github.io/>Gar Reversing</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>